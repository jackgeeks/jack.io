{"pages":[{"title":"404","text":"","link":"/wpp.io/404/index.html"},{"title":"search","text":"","link":"/wpp.io/search/index.html"}],"posts":[{"title":"解析Json工具类","text":"JsonJSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 解析Json工具类目前对于Java开源的JSON类库有很多种，下面我们取4个常用的JSON库进行性能测试对比， 同时根据测试结果分析如果根据实际应用场景选择最合适的JSON库。这4个JSON类库分别为：Gson，FastJson，Jackson，Json-lib。 Json-lib项目地址：http://json-lib.sourceforge.net/index.html json-lib最开始的也是应用最广泛的json解析工具，json-lib 不好的地方确实是依赖于很多第三方包，对于复杂类型的转换，json-lib对于json转换成bean还有缺陷， 比如一个类里面会出现另一个类的list或者map集合，json-lib从json到bean的转换就会出现问题。json-lib在功能和性能上面都不能满足现在互联网化的需求。Maven 依赖 123456&lt;dependency&gt; &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt; &lt;artifactId&gt;json-lib&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;classifier&gt;jdk15&lt;/classifier&gt;&lt;/dependency&gt; 基本操作 123456789101112131415161718192021public static void main(String[] args) throws IOException, InterruptedException { String json = ApiService.getApi(); JSONObject jsonObject = JSONObject.fromObject(json); String city = JSONObject.fromObject(jsonObject.get(&quot;cityInfo&quot;)).get(&quot;city&quot;).toString(); JSONArray jsonArray = JSONObject.fromObject(jsonObject.get(&quot;data&quot;)).getJSONArray(&quot;forecast&quot;); List&lt;weather&gt; weathers =new ArrayList&lt;&gt;(); System.out.println(jsonArray.size()); for (int i =0;i&lt;jsonArray.size();i++){ //转实体类 weather weather = (weather)JSONObject.toBean((JSONObject) jsonArray.get(i), weather.class); weathers.add(weather); } System.out.println(city); weathers.forEach(e-&gt;{ System.out.println(e); }); } Gson项目地址：https://github.com/google/gson Gson是目前功能最全的Json解析神器，Gson当初是为因应Google公司内部需求而由Google自行研发而来，但自从在2008年五月公开发布第一版后已被许多公司或用户应用。 Gson的应用主要为toJson与fromJson两个转换函数，无依赖，不需要例外额外的jar，能够直接跑在JDK上。 在使用这种对象转换之前，需先创建好对象的类型以及其成员才能成功的将JSON字符串成功转换成相对应的对象。 类里面只要有get和set方法，Gson完全可以实现复杂类型的json到bean或bean到json的转换，是JSON解析的神器。Maven 依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.6&lt;/version&gt;&lt;/dependency&gt; 基本操作 12345678910public static void main(String[] args) throws IOException, InterruptedException { Gson gson = new Gson(); List&lt;weather&gt; json = ApiService.GetList(); String toJson = gson.toJson(json); System.out.println(&quot;List转json:&quot;+toJson); List&lt;weather&gt; weathers=gson.fromJson(toJson, new TypeToken&lt;List&lt;weather&gt;&gt;() {}.getType()); System.out.println(&quot;json转List:&quot;+weathers); } FastJson项目地址：https://github.com/alibaba/fastjsonFastjson是一个Java语言编写的高性能的JSON处理器,由阿里巴巴公司开发。无依赖，不需要例外额外的jar，能够直接跑在JDK上。FastJson在复杂类型的Bean转换Json上会出现一些问题，可能会出现引用的类型，导致Json转换出错，需要制定引用。FastJson采用独创的算法，将parse的速度提升到极致，超过所有json库。 关于FastJson漏洞 fastjson 当前版本为 1.2.68 发布于 3 月底，日前某安全运营中心监测到，fastjson &lt;= 1.2.68 版本存在远程代码执行漏洞，漏洞被利用可直接获取服务器权限。360CERT 将漏洞等级定为“高危Maven 依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.72&lt;/version&gt; &lt;/dependency&gt; 基本操作123456789101112131415public class FastJson { public static void main(String[] args) throws IOException, InterruptedException { String json = ApiService.getApi(); JSONObject jsonObject = JSONObject.parseObject(json); Object data = jsonObject.get(&quot;data&quot;); String toJSONString = JSON.toJSONString(data); JSONArray jsonArray = JSONObject.parseObject(toJSONString).getJSONArray(&quot;forecast&quot;); List&lt;weather&gt; weathers = JSON.parseArray(JSON.toJSONString(jsonArray), weather.class); weathers.forEach(o-&gt;{ System.out.println(o); }); }} Jackson项目地址：https://github.com/FasterXML/jackson Jackson是当前用的比较广泛的，用来序列化和反序列化json的Java开源框架。Jackson社区相对比较活跃，更新速度也比较快， 从Github中的统计来看，Jackson是最流行的json解析器之一，Spring MVC的默认json解析器便是Jackson。 Jackson优点很多： Jackson 所依赖的jar包较少，简单易用。与其他 Java 的 json 的框架 Gson 等相比，Jackson 解析大的 json 文件速度比较快。Jackson 运行时占用内存比较低，性能比较好Jackson 有灵活的 API，可以很容易进行扩展和定制。Jackson 是spring推荐的json解析工具,拥有强大的注解 常用注解@JsonProperty: 属性使用的注解，用来表示外部属性名字，就是使用别名序列化，而不是对象的@JsonAutoDetect: 实体类使用的注解，用于重新设置实体类中属性的自动发现机制。@JsonFormat: 实体类/属性使用的注解，在序列化或者反序列化的时候，指定属性格式化日期/时间。 Maven 依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.10.2&lt;/version&gt;&lt;/dependency&gt; 基本操作 1234567891011121314151617181920212223public class JackJson { public static void main(String[] args) throws IOException, InterruptedException { List&lt;weather&gt; json = ApiService.GetList(); weather weather = json.get(0); System.out.println(&quot;对象转json：&quot;+JsonUtils.toJsonWithDefaultPrettyPrinter(weather)); Map&lt;String,Object&gt; map =new HashMap&lt;&gt;(); map.put(&quot;1&quot;,&quot;上海&quot;); map.put(&quot;2&quot;,&quot;北京&quot;); map.put(&quot;3&quot;,&quot;天津&quot;); map.put(&quot;4&quot;,&quot;深圳&quot;); Map&lt;String,Object&gt; map1 =new HashMap&lt;&gt;(); map1.put(&quot;city&quot;,map); Map&lt;String, Object&gt; objectMap = JsonUtils.removeMapEmptyValue(map); System.out.println(&quot;Map转json：&quot;+objectMap); String jsonTow = JsonUtils.toJsonWithDefaultPrettyPrinter(map1); System.out.println(&quot;Map嵌套转json&quot;+jsonTow); }} JsonUtils工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class JsonUtils { private static final ObjectMapper mapper; private JsonUtils() { } static { mapper = new ObjectMapper(); mapper.setDateFormat(new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;)); } public static final String toJson(Object obj) { try { return mapper.writeValueAsString(obj); } catch (Throwable e) { e.printStackTrace(); } return &quot;&quot;; } public static final String toJsonWithDefaultPrettyPrinter(Object obj) { try { return mapper.writerWithDefaultPrettyPrinter().writeValueAsString(obj); } catch (Throwable e) { e.printStackTrace(); } return &quot;&quot;; } public static final &lt;T&gt; T fromJson(final String json, Class&lt;T&gt; clazz) { try { return mapper.readValue(json, clazz); } catch (Throwable e) { e.printStackTrace(); } return null; } public static final &lt;T&gt; T fromJson(final String json, JavaType type) { try { return mapper.readValue(json, type); } catch (Throwable e) { e.printStackTrace(); } return null; } public static final &lt;T&gt; T fromJson(final String json, TypeReference&lt;T&gt; reference) { try { return mapper.readValue(json, reference); } catch (Throwable e) { e.printStackTrace(); } return null; } public static final Map&lt;String, Object&gt; fromJson(final String json) { return fromJson(json, Map.class); } public static Map&lt;String, Object&gt; removeMapEmptyValue(Map&lt;String, Object&gt; paramMap) { Set&lt;String&gt; set = paramMap.keySet(); Iterator&lt;String&gt; it = set.iterator(); List&lt;String&gt; listKey = new ArrayList&lt;String&gt;(); while (it.hasNext()) { String str = it.next(); if (paramMap.get(str) == null || &quot;&quot;.equals(paramMap.get(str))) { listKey.add(str); } } for (String key : listKey) { paramMap.remove(key); } return paramMap; }}","link":"/wpp.io/2020/08/13/%E8%A7%A3%E6%9E%90Json%E5%B7%A5%E5%85%B7%E7%B1%BB/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/wpp.io/2020/08/12/hello-world/"}],"tags":[],"categories":[]}